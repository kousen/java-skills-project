Welcome back to our series on Java design patterns. Today, we're looking at the Factory pattern, but I want to show you how it's actually used in modern Java 2025 - not the artificial examples you might have seen before.

The truth is, you use factory patterns every day in Java without even realizing it. Every time you call Optional.of(), List.of(), or Files.newBufferedReader(), you're using static factory methods. And when you're setting up HTTP clients or configuration parsers in real applications, you're often using factory classes.

Let's explore both the theory and the practical, real-world applications you'll encounter in professional Java development.

In modern Java, we primarily see two types of factory patterns. First, and most common, are static factory methods. These are simple static methods that return instances - like Optional.of() or List.of(). They're everywhere in the JDK.

Second, we have factory classes for more complex scenarios. These are typically used when you need to configure objects with multiple dependencies, like HTTP clients, database connections, or configuration parsers.

The traditional Gang of Four factory method pattern with abstract creators and concrete creators? That's largely been replaced by builders for complex object creation. But the core idea - hiding object creation complexity - is still everywhere.

Let's start with static factory methods, since these are what you'll use most often. Here are some you already know from the JDK.

Notice the naming conventions: of, ofNullable, now. These are much clearer than constructor names, and they can return cached instances or even different subclasses.

And here's one you probably use every day without thinking about it - SLF4J's LoggerFactory:

This is a perfect factory pattern - it hides which logging implementation you're using and returns the appropriate logger. We'll dive deep into this in Section 19 on logging.

(Show design-patterns/src/main/java/ModernFactoryPatterns.java on screen)

Now let's look at a real-world factory class. In modern applications, you often need different HTTP client configurations - basic clients, resilient clients with retries, authenticated clients. Here's how you'd use a factory for that.

Here's how you'd use these factories in real code. The client code is clean and expressive.

The beautiful part is that all these return the same HttpClient interface, so your code can work with any of them polymorphically. You can switch from a basic client to a resilient client just by changing one line.

Here's another real-world example - configuration parsers. You often need to parse JSON, YAML, or Properties files. Instead of hardcoding the parser type, you use a factory based on the file extension or content type.

Let's wrap up with the key takeaways for factory patterns in modern Java 2025.

First, static factory methods are everywhere and should be your go-to approach. They're clearer than constructors, can return cached instances, and follow established naming conventions like of, from, valueOf, and getInstance.

Second, factory classes are still valuable for some scenarios, though builders have largely taken over complex object creation. You'll see factories mainly in framework integration - like Spring's BeanFactory or SLF4J's LoggerFactory, which we'll cover in our logging section.

Third, the traditional Gang of Four factory method pattern with abstract creators? That's mostly been replaced by builders. But the core principle - hiding creation complexity from client code - is more relevant than ever.

You're already using factory patterns every day in Java. Now you know the theory behind them and can apply the pattern intentionally in your own code.

That's the modern Factory pattern in Java 2025. Thanks for watching!