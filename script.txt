Welcome back to our deep dive into the SOLID principles. In this video, we're tackling the 'O': The Open/Closed Principle.

The Open/Closed Principle, or OCP, states that software entities—like classes or modules—should be open for extension, but closed for modification. This sounds a bit like a contradiction, but it's a powerful idea. It means you should be able to add new functionality to your system without changing existing, working code.

And just to be clear, when we say OCP, we're talking about the Open/Closed Principle, not Omni Consumer Products from RoboCop - though ironically, that corporation was a perfect example of violating this principle by trying to control everything from one monolithic entity!

The key to achieving this is through abstraction. By programming to interfaces rather than concrete implementations, you can create systems that are flexible and resilient to change.

Let's consider a classic example: a class that calculates the area of different shapes. A naive implementation might have a single method with a long if-else-if chain, checking the type of the shape and then calculating its area.

(Show the OCP violation slide)

This code works, but it has a major flaw. What happens when your boss asks you to add a Triangle? You have to go back into this calculateArea method and add another else if block. You are modifying existing code. This is a violation of the Open/Closed Principle. Every time a new shape is added, this class has to change. This is risky, because you might accidentally break the logic for rectangles or circles, and it means the class needs to be fully re-tested every time.

So how do we fix this? We use abstraction. We can create a Shape interface that declares a getArea method. Then, each of our shape classes—Rectangle, Circle, and our new Triangle—will implement this interface and provide its own specific logic for calculating its area.

Now, our AreaCalculator class becomes incredibly simple. Its calculateArea method just takes any object that implements the Shape interface and calls its getArea method.

This is beautiful. If we need to add a Pentagon shape tomorrow, we just create a new Pentagon class that implements Shape. The AreaCalculator doesn't need to be touched. It's closed for modification, but it's open to be extended with new shapes. That's the principle in action.

Our project demonstrates this beautifully with an employee payroll system.

(Show solid-principles/src/main/java/OpenClosedPrinciple.java on screen)

We have an abstract OCPEmployee class that defines the contract for all employees. It uses the template method pattern with a calculatePay method that calls abstract methods like getBasePay, calculateBonus, and calculateBenefits. Each subclass provides its own implementation.

We have different employee types: FullTimeEmployee, PartTimeEmployee, ContractEmployee, and InternEmployee. Each extends the base class and implements the abstract methods according to their specific business rules. Full-time employees get benefits based on salary, part-time employees get prorated benefits, contractors get completion bonuses, and interns get learning value.

The beauty is in the PayrollCalculator class. It works with any employee type through polymorphism. When we added the InternEmployee class, we didn't touch the PayrollCalculator at all. It automatically works with the new type. The calculator is closed for modification but open for extension with new employee types.

Now it's your turn to practice implementing the Open/Closed Principle. In the same solid-principles module, you'll find the OCPDiscountCalculatorExercise file. This gives you hands-on experience with a realistic e-commerce scenario: refactoring a discount calculation system.

The exercise starts with a BadDiscountCalculator that violates OCP. It has a long if-else chain checking for different discount types like 'STUDENT', 'SENIOR', 'EMPLOYEE', 'BULK', and 'LOYALTY'. Every time you want to add a new discount type like 'HOLIDAY' or 'CLEARANCE', you have to modify this class. Sound familiar?

Your job is to refactor this using the Strategy pattern combined with abstract classes. You'll create a DiscountStrategy abstract class and implement concrete strategies like StudentDiscountStrategy, SeniorDiscountStrategy, and BulkOrderDiscountStrategy. Each strategy handles one specific type of discount calculation.

What makes this exercise valuable is that it uses a realistic business scenario with different customer types, order thresholds, and complex discount rules. You'll see how much cleaner the code becomes when each discount type is its own focused class.

The exercise includes TODO comments guiding you through implementing each strategy, so you can focus on applying OCP principles rather than figuring out business logic. The best part? Once you're done, try adding your own creative discount strategy - maybe a HolidayDiscountStrategy or FirstTimeBuyerDiscount. You'll see how easy it is to extend the system without touching any existing code.

Before we wrap up, it's worth noting that Template Method and Strategy patterns aren't the only ways to implement OCP. There are several other common approaches you'll encounter in real-world Java development.

The Strategy pattern, which we used in our discount exercise, is probably the most common. You create an interface and multiple implementations. The Factory pattern helps with object creation while staying extensible. Observer pattern lets you add event listeners without modifying the publisher.

Modern Java also gives us functional approaches. You can use Function interfaces and lambdas to create extensible systems. For example, instead of creating separate discount classes, you could pass discount functions directly to your calculator.

Framework-based development often uses annotation-driven extension points. Think Spring components - you can add new service implementations just by annotating them, and the framework discovers them automatically.

The key insight is that OCP isn't about one specific pattern. It's a principle that can be achieved through many different techniques, depending on your specific needs and context.

To sum up, the Open/Closed Principle is a vital concept for building flexible and maintainable software. By relying on abstractions, you can create components that are open to being extended with new functionality, without having to modify their existing, stable source code.

This leads to systems that are easier to change, less risky to update, and more modular in their design.

That's it for OCP. Next time, we'll explore the 'L' in SOLID, the Liskov Substitution Principle.