[SCENE 1: INTRODUCTION - 30 SECONDS]

(Show Slide 1: Java Logging Frameworks)

Welcome back to our Java Skills series. Today, we're moving beyond System.out.println and into professional logging frameworks. If you've ever struggled to debug a production issue or wondered where all those println statements went, this video is for you.

[SCENE 2: WHY LOGGING MATTERS - 45 SECONDS]

(Show Slide 3: Why Logging Matters)

Let me ask you something - have you ever deployed code only to realize you can't see what's happening when something goes wrong? That's where logging comes in. Proper logging gives us application diagnostics - we can debug issues in production, track application behavior, and monitor performance.

(Show Slide 4: Better Than System.out.println)

Unlike System.out.println, proper logging lets you control output levels, write to multiple destinations, and format messages consistently. You can turn on debug messages in development and turn them off in production - all without changing your code.

[SCENE 3: JAVA LOGGING OPTIONS - 45 SECONDS]

(Show Slide 5: Java Logging Options)

Java gives us several logging options. There's java.util.logging built right into the JDK, but it's simple and has limited features. The popular frameworks include SLF4J - the Simple Logging Facade - paired with implementations like Logback or Log4j2.

(Show Slide 6: SLF4J + Logback Setup)

Think of SLF4J as an interface and Logback as the implementation. This separation means you can switch logging frameworks without changing your code. And notice - these dependencies are already in our project! We're using SLF4J 2.0.17 and Logback 1.5.18.

[SCENE 4: CREATING YOUR FIRST LOGGER - 45 SECONDS]

(Show Slide 7: Creating a Logger)

Let's create our first logger. Notice the pattern here - we create a static logger using LoggerFactory.getLogger and pass in our class. This becomes our gateway to the logging system.

(Transition to IDE showing EmployeeLogger.java)

When we call logger.info, we're using parameterized messages. See those curly braces? They're placeholders that get replaced with actual values - but only if that log level is enabled. This is way more efficient than string concatenation.

[SCENE 5: UNDERSTANDING LOG LEVELS - 45 SECONDS]

(Show Slide 8: Logging Levels)

Logging frameworks use levels to categorize messages. From least to most severe, we have TRACE for detailed diagnostic information, DEBUG for debugging, and INFO for general information.

(Show Slide 9: Logging Levels (continued))

Then we have the error levels: WARN for warning messages, ERROR for error conditions, and OFF to turn off logging completely.

(Show Slide 10: Using Different Log Levels)

Look at this validation example in our EmployeeLogger. We use TRACE for the most detailed info, ERROR when something's definitely wrong, WARN for suspicious but not fatal issues, and DEBUG to track our progress. The beauty is that you can set your production systems to only show WARN and ERROR, while keeping all levels active during development.

[SCENE 6: EFFICIENT LOGGING TECHNIQUES - 45 SECONDS]

(Show Slide 11: Parameterized Messages)

Here's a crucial performance tip. Instead of string concatenation, use parameterized messages. The bad way concatenates strings whether logging is enabled or not. The good way only concatenates if that log level is enabled. This can save significant performance in production.

(Show Slide 12: Exception Logging)

When logging exceptions, pass the exception as the last parameter to get the full stack trace. This gives you all the diagnostic information you need to track down problems.

[SCENE 7: CONFIGURATION AND ADVANCED FEATURES - 105 SECONDS]

(Show Slide 13: Logback Configuration)

Logback uses an XML configuration file, and it's simpler than it looks. This basic configuration creates a console appender with a specific pattern.

(Show Slide 14: Log Pattern Elements)

The pattern controls how each log line looks. You have date and time, thread name, log level padded to 5 characters...

(Show Slide 15: Log Pattern Elements (continued))

...logger name truncated to 36 characters, the actual message, and a line separator.

(Show Slide 16: File Appender)

You can write to files by adding a file appender. This logs to both console and file simultaneously.

(Show Slide 17: Rolling File Appender)

For production, use a rolling file appender that automatically creates new log files each day and deletes old ones to save disk space.

(Show Slide 18: Logger Hierarchy)

Configure different log levels for different packages. Root logger at INFO, your application package at DEBUG, and third-party libraries at WARN to reduce noise.

[SCENE 8: PERFORMANCE AND CONTEXT - 90 SECONDS]

(Show Slide 19: Conditional Logging)

For expensive operations, check if the log level is enabled first. This avoids creating expensive debug strings when they won't be logged anyway.

(Show Slide 20: MDC (Mapped Diagnostic Context))

Here's a pro tip - use MDC, the Mapped Diagnostic Context, to add context to all your logs. By putting user ID and request ID into MDC, every log message in that thread automatically includes this context.

(Show Slide 21: MDC in Log Pattern)

Configure your pattern to include MDC values, and you get rich contextual information in every log message. This is invaluable when tracking issues across multiple components.

(Show Slide 22: Async Logging)

For high-volume applications, use async appenders to improve performance by writing logs on a separate thread.

[SCENE 9: BEST PRACTICES AND MIGRATION - 60 SECONDS]

(Show Slide 23: Best Practices)

Follow these logging guidelines: use appropriate log levels, include context in messages, and avoid logging sensitive data like passwords.

(Show Slide 24: Best Practices (continued))

For performance, use parameterized messages, guard expensive operations, and configure async appenders for high volume applications.

(Show Slide 25: Common Mistakes)

Avoid these common mistakes: logging at the wrong level, including passwords or personal information, and excessive DEBUG logging in production.

(Show Slide 26: Migration from println)

Here's how to migrate from System.out.println. Replace print statements with appropriate logger calls, and pass exceptions as parameters for stack traces.

[SCENE 10: SUMMARY AND NEXT STEPS - 30 SECONDS]

(Show Slide 27: Summary)

Proper logging is the difference between guessing what went wrong and knowing exactly what happened. Logging provides better diagnostics than println, SLF4J plus Logback is a popular choice, configure levels and appenders appropriately, use MDC for request context, and follow best practices for performance.

[SCENE 11: TRY IT OUT EXERCISE - 30 SECONDS]

Now it's time for you to practice! In the foundations module, you'll find LoggingExercise.java - a hands-on exercise with TODO sections covering all the concepts we've discussed.

Complete the TODOs to practice creating loggers, using parameterized messages, implementing conditional logging, working with MDC context, and handling exceptions. Each section builds on the previous one, so you'll get comprehensive logging experience.

You can also examine EmployeeLogger.java for a complete working example that demonstrates all these concepts in action.

(Show Slide 28: Next: Consuming REST APIs)

Next time, we'll use Java's HTTP client to consume REST APIs. Until then, happy coding, and may your logs always be informative!