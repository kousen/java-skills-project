[SCENE 1: INTRODUCTION - 30 SECONDS]

Welcome back! Last time, we learned how to consume REST APIs. Now let's flip the script and create our own REST services. We'll build a comprehensive, production-ready API with proper layered architecture using Spring Boot.

[SCENE 2: WHY SPRING BOOT? - 30 SECONDS]

Spring Boot is the industry standard for a reason. It follows convention over configuration, includes production-ready features built-in, and provides an exceptional developer experience.

Minimal boilerplate code, embedded server included, auto-configuration magic. It's like having a senior architect design your application structure for you.

[SCENE 3: PROJECT STRUCTURE - 30 SECONDS]

We're working with a multi-module Gradle project. Our web-services module focuses on REST APIs, with Spring Boot Web starter and validation dependencies already configured.

Here's our WebServicesApplication. One @SpringBootApplication annotation gives us component scanning, auto-configuration, and an embedded Tomcat server. That's it - we're ready to build APIs.

[SCENE 4: LAYERED ARCHITECTURE - 45 SECONDS]

Instead of building a simple controller, we'll create proper layered architecture. Controller layer handles REST endpoints, Service layer contains business logic and validation, Repository layer manages data access.

Our EmployeeRepository uses @Repository annotation and handles data persistence. Notice we're using a modern Java record for Employee, with immutable data and helper methods like withId().

[SCENE 5: SERVICE LAYER WITH BUSINESS LOGIC - 30 SECONDS]

The Service layer is where the magic happens. Our EmployeeService contains business constants, validation logic, and operations like processNewHire() and giveRaise(). Notice how it validates salary ranges and handles business rules.

We've also added professional transaction boundaries with @Transactional annotations. The service class uses @Transactional for write operations and @Transactional(readOnly = true) for queries. This demonstrates proper enterprise patterns even with in-memory storage.

Our main application class uses @EnableTransactionManagement to activate Spring's transaction infrastructure. This shows how to structure applications for easy database migration later - just change the storage backend and your transaction boundaries are already defined.

The Controller layer stays focused on HTTP concerns. Look at the constructor injection - Spring automatically wires the EmployeeService. The controller methods handle ResponseEntity for proper HTTP status codes and headers.

[SCENE 6: MODERN JAVA FEATURES - 30 SECONDS]

We're using Java records for immutable data. No getters, setters, or equals/hashCode boilerplate. The withId() and withSalary() helper methods create new instances for updates - that's immutable design done right.

Instead of bean validation annotations, we implement business logic validation in the service layer. This gives us complete control over validation rules and custom error messages.

[SCENE 7: EXCEPTION HANDLING - 30 SECONDS]

Modern exception handling uses ProblemDetail from RFC 7807. Our GlobalExceptionHandler catches EmployeeNotFoundException and returns structured error responses with proper HTTP status codes.

[SCENE 8: BUSINESS LOGIC ENDPOINTS - 30 SECONDS]

This is where our architecture shines. We're not just doing basic CRUD - we have business operations like giveRaise(), giveStandardRaise(), and getHighPerformers(). Each endpoint encapsulates real business logic.

[SCENE 9: TESTING STRATEGY - 30 SECONDS]

Our layered architecture enables comprehensive testing. Repository tests are pure unit tests with no Spring context. Service tests use Spring Boot integration with @MockitoBean. Controller tests use @WebMvcTest for the web layer.

MockMvc simulates HTTP requests without starting a server. We mock the service layer and test HTTP status codes, JSON responses, and request mapping. This gives us fast, focused web layer testing.

[SCENE 10: RUNNING AND SUMMARY - 30 SECONDS]

Our multi-module project separates concerns beautifully. Run gradle :web-services:bootRun and you'll have a full REST API at localhost:8080. Try the /api/employees/hello endpoint to see it in action.

We've built a production-ready REST API with proper layered architecture. Modern Java records, comprehensive business logic, and testing at all three layers. This is how you build maintainable, scalable APIs.

Spring Boot makes the plumbing invisible so you can focus on business value. Clean separation of concerns means each layer has a single responsibility, making the code easier to test, maintain, and extend.

[SCENE 11: TRY IT OUT EXERCISE - 30 SECONDS]

Now it's time to put your REST controller skills to work! Open the `EmployeeSearchController.java` file in the web-services module. You'll find four TODOs that guide you through implementing search endpoints.

This exercise demonstrates real-world patterns: constructor injection, GET endpoints with path variables, POST endpoints with request bodies, and stream-based filtering. The best part? You'll reuse our existing EmployeeService - no duplicate business logic needed!

Start with TODO #1 for constructor injection, then implement the department search GET endpoint. The POST endpoint for advanced search is where it gets interesting - you'll use Java streams to filter by multiple criteria. Finally, create a simple endpoint that returns unique department names.

Run the provided tests to verify your implementation. This exercise shows you how real REST APIs are built in production - clean separation of concerns with focused controllers that delegate to service layers.

[SCENE 12: CONCLUSION - 15 SECONDS]

Next time, we'll dive deeper into input validation and preventing security vulnerabilities like SQL injection and XSS attacks. Because building great APIs is just the first step - securing them is equally important!

Thanks for watching, and I'll see you in the next video where we'll make our APIs bulletproof!