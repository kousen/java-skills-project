[PART 1: ON-CAMERA INTRODUCTION - 90 SECONDS]

Welcome back to the Java series. Even though we've been talking about Java. This time we're going to talk about something equally important to your professional development, and that's git collaboration. Almost everybody works on a team these days, and Git and GitHub are the two primary tools that we use to maintain our code under what we call source code control.

Whether you're contributing to open source projects or working on a development team, or just want to follow industry best practices, mastering git collaboration is crucial.  So let's talk about the complete workflow for contributing to a Java project on git or GitHub using a forked based collaboration. There are other approaches, but this one is widespread. This is a standard approach used in many open source projects as well as professional environments. We'll walk through the whole process, forking a repository, creating a feature branch, making commits with proper messages, handling conflicts, creating pull requests, getting your code reviewed, and ultimately merged into the repository.

Since we need an example, a project to work with, I'm going to use the source code repository for our current project, the Java Skills project, as the example. It is currently live on GitHub, and you can follow along with the exact same steps that I'm going to walk through. By the end of the video, hopefully you'll see how to contribute to any Java project successfully.

So let's dive in and see how real git collaboration works.

[PART 2: SCREEN-SHARE DEMONSTRATION - 5 MINUTES 30 SECONDS]

[SWITCH TO SCREEN SHARE]

[SETTING UP THE FORK WORKFLOW - 60 SECONDS]

[Screen: Show GitHub repository page]

(Display text overlay: "github.com/kousen/java-skills-project")

First, let's start with a GitHub repository for our Java skills project. I'm going to show you the fork-based workflow, which is what you'd use when contributing to a project that you don't own. Here is our project repository. You see that it has all the Java modules we've been working with throughout this series, the design patterns, the foundations, the OOP core, et cetera.

Before contributing to any open source project, you should always look for contribution guidelines and the code of conduct. Most projects have a CONTRIBUTING.md file and a CODE_OF_CONDUCT.md file, or these may be included in the README or documentation. The contribution guidelines tell you about coding standards, testing requirements, and workflow preferences. The code of conduct explains the community standards for respectful collaboration and what behavior is expected from contributors.

(Display text overlay: "Always check: CONTRIBUTING.md + CODE_OF_CONDUCT.md")

[Screen: Click on Issues tab]
(Display text overlay: "5 open issues available for contribution")

Notice that we also have several open issues here. These represent real features and or bugs that need to be implemented or fixed. But before jumping in, you should always look for the contribution guidelines and the code of conduct.  Most projects have them, and they have particular names for the files, and if you name them the right thing, then on GitHub they will show up as links right at the top of the Read me here.

So let's start with issue #1—'Add employee search functionality with pagination.' This is exactly the kind of task you'd pick up as a contributor. Once we have selected an issue, it's time to fork the repository. That's the start of the process for modifying a project you don't own. On the code page of the repository, there's a fork button, and that's where you start. A fork is a copy of a repository under your own account. Forking repository allows you to freely experiment with changes without affecting the original project

[Screen: Click Fork button]
(Display text overlay: "Click 'Fork' to create your own copy")

First step—I fork the repository. I'm going to fork this to my groovy-podcast organization account, but you would fork it to your personal GitHub account. This creates my own copy that I can modify freely without affecting the original.

[Screen: Show forked repository]

Great! Now I have my own fork. Let's clone it locally and set up the proper remotes.

[Screen: Open terminal]

# Clone MY fork, not the original
git clone https://github.com/groovy-podcast/java-skills-project.git
cd java-skills-project

(Display text overlay: "Always clone your fork, not the original")

Now I need to add the original repository as an 'upstream' remote:

# Add the original repo as upstream
git remote add upstream https://github.com/kousen/java-skills-project.git
git remote -v

(Display text overlay: "upstream = original repo, origin = your fork")

Perfect! Now I have both remotes configured properly.

[CREATING AND WORKING ON A FEATURE BRANCH - 75 SECONDS]

Before starting any work, I always sync with the upstream repository:

# Get the latest changes from upstream
git fetch upstream
git checkout main
git merge upstream/main
git push origin main

(Display text overlay: "Always sync before starting new work")

Now let's create a feature branch for our work:

# Create feature branch for issue #1
git checkout -b feature/employee-search
git push -u origin feature/employee-search

(Display text overlay: "Branch name connects to issue: feature/employee-search")

Let me make some changes to implement the employee search functionality. I'll edit a few files to add the search endpoints.

[Screen: Show code editor, make realistic changes to a Java file]

# Check what we've changed
git status
git diff

(Display text overlay: "Always review your changes before committing")

Now let's commit with a proper commit message:

git add web-services/src/main/java/com/oreilly/webservices/EmployeeController.java
git commit -m "Add employee search functionality with pagination

- Implement search by name, department, and salary range
- Add pagination support with page/size parameters  
- Include input validation for search criteria
- Add comprehensive unit tests for search methods

Fixes #1"

(Display text overlay: "Good commit messages: imperative mood, explain why, reference issues")

[STAYING IN SYNC AND HANDLING CONFLICTS - 60 SECONDS]

While I was working, the upstream repository might have changed. Let me sync again:

# Ensure we're on the demo branch
git checkout feature/employee-search-demo

# Fetch latest changes
git fetch upstream

# Rebase my feature branch against upstream main
git rebase upstream/main

(Display text overlay: "Rebase keeps a clean, linear history")

Oh look, there's a conflict! This is totally normal in collaborative development.

[Screen: Show conflict in code editor - the actual conflict will appear around the `/search` vs. `/find` endpoints]

The conflict will show something like:

// <<<<<<< HEAD (your searchEmployees method)
    @GetMapping("/search")
    public ResponseEntity<List<Employee>> searchEmployees(
            @RequestParam String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        // Your pagination implementation
        return employeeService.findByNameContaining(name);
    }
// =======
    @GetMapping("/find")
    public ResponseEntity<List<Employee>> findEmployees(@RequestParam String query) {
        // Their simpler implementation from main
        return employeeService.search(query);
    }
// >>>>>>> upstream/main

(Display text overlay: "Conflicts show: your changes (top) vs their changes (bottom)")

I need to resolve this by choosing the best approach. I'll keep my more comprehensive implementation but adopt their simpler endpoint name:

@GetMapping("/find")
public ResponseEntity<List<Employee>> searchEmployees(
        @RequestParam String name,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size) {
    // Keep my pagination implementation but use their endpoint
    logger.info("Searching employees with name containing: '{}', page: {}, size: {}", name, page, size);
    
    List<Employee> employees = employeeService.findByNameContaining(name);
    
    // Apply pagination
    int start = page * size;
    int end = Math.min(start + size, employees.size());
    List<Employee> paginatedEmployees = start < employees.size() ? 
        employees.subList(start, end) : List.of();
    
    return ResponseEntity.ok()
        .header("X-Total-Count", String.valueOf(employees.size()))
        .body(paginatedEmployees);
}

# Mark conflict as resolved
git add web-services/src/main/java/com/oreilly/webservices/EmployeeController.java
git rebase --continue

(Display text overlay: "Edit file, remove conflict markers, add file, continue rebase")

[CREATING A PULL REQUEST - 75 SECONDS]

Now my feature is ready. Let's push it and create a pull request:

# Push to my fork
git push --force-with-lease origin feature/employee-search

(Display text overlay: "--force-with-lease is safer than --force")

[Screen: Go to GitHub, show PR creation]

Back on GitHub, I'll create a pull request from my fork to the upstream repository.

[Screen: Click 'New Pull Request,' show cross-repo PR setup]
(Display text overlay: "Creating PR: from my-fork/feature-branch to upstream/main")

Notice GitHub automatically loads our comprehensive PR template. This is much more detailed than what you typically see in tutorials.

[Screen: Show PR template being filled out]
(Display text overlay: "Professional PR template includes: testing, security, documentation checklist")

I'll fill this out properly:
- Summary of what I implemented
- Testing details 
- Security considerations
- Documentation updates

[Screen: Submit PR]

[CODE REVIEW AND CI INTEGRATION - 60 SECONDS]

Once I submit the PR, several things happen automatically:

[Screen: Show PR page with CI checks]
(Display text overlay: "Automated CI runs: builds project, runs tests, checks quality")

Our GitHub Actions workflow automatically builds the project and runs tests. You can see the green checkmarks showing everything passed.

[Screen: Show review comments section]

Now the maintainer can review my code. They might ask for changes:

(Display text overlay: "Code review is collaborative—be open to feedback")

If they request changes, I just make them on my local branch and push:

# Make requested changes
git add .
git commit -m "Address code review feedback - add input validation"
git push origin feature/employee-search

(Display text overlay: "PR automatically updates when you push to the branch")

[Screen: Show PR getting approved and merged]

Once approved, the maintainer merges the PR. My contribution is now part of the main project!

[CLEANUP - 15 SECONDS]

Finally, I clean up my local environment:

# Switch back to main and sync
git checkout main
git fetch upstream
git merge upstream/main
git push origin main

# Delete feature branch
git branch -d feature/employee-search
git push origin --delete feature/employee-search

(Display text overlay: "Always clean up merged branches")

[END SCREEN SHARE]

[PART 3: ON-CAMERA SUMMARY - 75 SECONDS]

And that's the complete Git collaboration workflow! Let me summarize the key lessons we learned today.

First, always check for contribution guidelines and code of conduct before starting work. Look for CONTRIBUTING.md and CODE_OF_CONDUCT.md files, or similar sections in the README or documentation. These explain the project's technical requirements and community standards for respectful collaboration.

Second, fork-based workflows are the standard for open source and external contributions. You fork the repository, work in your own copy, and submit pull requests to contribute back. This keeps the original repository clean and gives maintainers full control.

Third, proper branch management is crucial. Always create feature branches, never work directly on main. Keep your branches focused on specific issues or features, and use descriptive names that connect to your issues.

Fourth, commit messages matter. Write them in the imperative mood, keep the first line short, and explain why you made the change, not just what you changed. Good commits tell the story of your code.

Fifth, stay synchronized with upstream. Projects evolve constantly, so fetch regularly and rebase your work against the latest main branch. This prevents conflicts and keeps your contributions relevant.

Finally, embrace code review. It's not criticism—it's collaboration. Be open to feedback, ask questions when something's unclear, and remember that the goal is better code for everyone.

For your hands-on exercise, I want you to practice the complete Git collaboration workflow including conflict resolution. The repository includes a special exercise designed just for this purpose.

Start with the conflict resolution exercise: Open `git-workflows/CONFLICT_DEMO_BRANCHES.md` in the repository. This "Try It Out: Git Merge Conflict Resolution" exercise walks you through the exact scenario we just demonstrated - resolving a realistic merge conflict between competing employee search implementations.

Then explore the broader workflow: The `git-workflows/git-workflow-examples.md` file has comprehensive examples covering fork-based workflows, branch strategies, and professional Git practices for team collaboration.

This isn't just practice—if you create a quality pull request, it might actually get merged into the project! That would give you a real open source contribution to show on your résumé.

Git collaboration skills are essential for any professional Java developer. Whether you're joining a team, contributing to open source, or just following best practices, these workflows will serve you well throughout your career.

Next time, we'll dive into microservices architecture with Spring Boot. Until then, happy collaborating!